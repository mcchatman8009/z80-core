#include "ByteOperationHandler.h"
#include <EVEN_PARITY.h>

class ByteResultBuilder {
    public:
        inline void byteValue(Z80Byte byteValue) {
            this->data = byteValue;
        }

        inline void carryBit(bool carryBit) {
            this->carry = carryBit;
        }

        inline void halfCarryBit(bool halfCarryBit) {
            this->halfCarry = halfCarryBit;
        }

        inline void signBit(bool signValue) {
            this->sign = signValue;
        }

        inline void hasParity(bool parityValue) {
            this->parity = parityValue;
        }

        inline void isZero(bool isValueZero) {
            this->zero = isValueZero;
        }

        inline ByteResult build() {
            return ByteResult(data, carry, halfCarry, sign, zero, parity);
        }

    private:
        Z80Byte data{0x0};
        bool carry{false};
        bool halfCarry{false};
        bool sign{false};
        bool zero{false};
        bool parity{false};
};

using byte = unsigned char;

constexpr bool halfCarry(byte a, byte b, int c = 0) {
    auto num = (c > 0) ? 1 : 0;
    return (num + (0xF & a) + (b & 0xF)) > 0xF; // NOLINT
}

constexpr bool detectAddOverflow(byte a, byte b, int c = 0) {
    //
    // Internally, the overflow flag is usually generated by
    // an exclusive or of the internal carry into and out of
    // the sign bit. As the sign bit is the same as the most
    // significant bit of a number considered unsigned, the
    // overflow flag is "meaningless" and normally ignored
    // when unsigned numbers are added or subtracted.
    //
    int result = a + b + c;
    int carryBits = a ^b ^c ^result; // NOLINT
    return (((carryBits << 1) ^ carryBits) & 0x100) > 0; // NOLINT
}

constexpr bool detectSubtractionOverflow(byte a, byte b, int c = 0) {
    int result = a - b - c;
    int carrybits = a ^b ^c ^result; // NOLINT
    return ((((carrybits << 1) ^ carrybits) & 0x100) != 0); // NOLINT
}

constexpr bool carry(byte a, byte b, byte c = 0) {
    auto num = (c > 0) ? 1 : 0;
    return (num + a + b) > 0xFF; //NOLINT
}

constexpr bool halfBorrow(byte a, byte b, int c = 0) {
    auto num = (c > 0) ? 1 : 0;
    return ((0xF & a) - (b & 0xF) - num) < 0; // NOLINT
}

constexpr bool borrow(byte a, byte b, int c = 0) {
    auto num = (c > 0) ? 1 : 0;
    return (a - b - num) < 0;
}

static inline bool hasEvenParity(byte value) {
    int count = 0;
    std::bitset<8> bits = value;
    constexpr auto NUM_OF_BITS = 8;

    for (int bit = 0; bit < NUM_OF_BITS; bit++) {
        if (bits.test(bit))
            count++;
    }

    return count == 0 || (count % 2) == 0;
}

ByteResult ByteOperationHandler::increment(Z80Byte data) { // NOLINT
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() + 1);

    builder.carryBit(carry(data.getValue(), 1));
    builder.halfCarryBit(halfCarry(data.getValue(), 1));
    builder.hasParity(detectAddOverflow(data.getValue(), 1));
    builder.signBit(value.isBitEnabled(7)); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::decrement(Z80Byte data) { // NOLINT
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() - 1);

    builder.carryBit(borrow(data.getValue(), 1));
    builder.halfCarryBit(halfBorrow(data.getValue(), 1));
    builder.hasParity(detectSubtractionOverflow(data.getValue(), 1));

    builder.signBit(value.isBitEnabled(7));
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::add(Z80Byte lhs, Z80Byte rhs, int carryIn) { // NOLINT
    ByteResultBuilder builder;
    auto value = Z80Byte(lhs.getValue() + rhs.getValue() + carryIn);

    builder.carryBit(carry(lhs.getValue(), rhs.getValue(), carryIn));
    builder.halfCarryBit(halfCarry(lhs.getValue(), rhs.getValue(), carryIn));
    builder.hasParity(detectAddOverflow(rhs.getValue(), lhs.getValue(), carryIn));

    builder.signBit(value.isBitEnabled(7));
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::subtract(Z80Byte lhs, Z80Byte rhs, int carryIn) { // NOLINT
    ByteResultBuilder builder;
    auto value = Z80Byte(lhs.getValue() - rhs.getValue() - carryIn);

    builder.carryBit(borrow(lhs.getValue(), rhs.getValue(), carryIn));
    builder.halfCarryBit(halfBorrow(lhs.getValue(), rhs.getValue(), carryIn));
    builder.hasParity(detectSubtractionOverflow(lhs.getValue(), rhs.getValue(), carryIn));

    builder.signBit(value.isBitEnabled(7));
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::logicalAnd(Z80Byte lhs, Z80Byte rhs) { // NOLINT
    ByteResultBuilder builder;
    auto value = Z80Byte(lhs.getValue() & rhs.getValue());

    builder.carryBit(false);
    builder.halfCarryBit(false);

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit(value.isBitEnabled(7));
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::logicalOr(Z80Byte lhs, Z80Byte rhs) {
    ByteResultBuilder builder;
    auto value = Z80Byte(lhs.getValue() | rhs.getValue());

    builder.carryBit(false);
    builder.halfCarryBit(false);

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit(value.isBitEnabled(7)); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::logicalXOR(Z80Byte lhs, Z80Byte rhs) {
    ByteResultBuilder builder;
    auto value = Z80Byte(lhs.getValue() ^ rhs.getValue());

    builder.carryBit(false);
    builder.halfCarryBit(false);

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit(value.isBitEnabled(7)); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::complement(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte(~data.getValue());

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::rotateLeftCircular(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() << 1); // NOLINT

    if ((data.getValue() & 0x80) == 0x80) { // NOLINT
        builder.carryBit(true);
        value = Z80Byte(value.getValue() | 1); // NOLINT
    } else {
        builder.carryBit(false);
    }

    builder.hasParity(hasEvenParity(value.getValue()));
    builder.isZero(value.getValue() == 0);
    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::rotateRightCircular(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() >> 1); // NOLINT

    if ((data.getValue() & 0x01) != 0) { // NOLINT
        builder.carryBit(true);
        value = Z80Byte(value.getValue() | 0x80); // NOLINT
    } else {
        builder.carryBit(false);
    }

    builder.isZero(value.getValue() == 0);
    builder.hasParity(hasEvenParity(value.getValue()));
    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::rotateLeftThroughCarry(Z80Byte data, bool carryIn) {
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() << 1); // NOLINT

    if (carryIn) {
        value = Z80Byte{value.getValue() | 0x01}; // NOLINT
    }

    builder.carryBit((data.getValue() & 0x80) != 0); // NOLINT

    builder.isZero(value.getValue() == 0);
    builder.hasParity(hasEvenParity(value.getValue()));
    builder.signBit(signFromValue(value));
    builder.halfCarryBit(false);
    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::rotateRightThroughCarry(Z80Byte data, bool carryIn) {
    ByteResultBuilder builder;
    auto value = Z80Byte(data.getValue() >> 1); // NOLINT

    if (carryIn) {
        value = Z80Byte{value.getValue() | 0x80}; // NOLINT
    }


    builder.carryBit((data.getValue() & 0x01) != 0); // NOLINT
    builder.isZero(value.getValue() == 0);
    builder.hasParity(hasEvenParity(value.getValue()));
    builder.signBit(signFromValue(value));
    builder.halfCarryBit(false);
    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::shiftLeftArithmetic(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte((data.getValue() << 1) & (~1)); // NOLINT

    builder.carryBit((data.getValue() & 0x80) == 0x80); // NOLINT

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit((value.getValue() & 0x80) > 0); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::shiftRightArithmetic(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte((data.getValue() >> 1) | (data.getValue() & 0x80)); // NOLINT

    builder.carryBit((data.getValue() & 0x01) == 0x01); // NOLINT

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit((value.getValue() & 0x80) > 0); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::shiftLeftLogical(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte((data.getValue() << 1) | (0x1)); // NOLINT

    builder.carryBit((data.getValue() & 0x80) == 0x80); // NOLINT

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit((value.getValue() & 0x80) > 0); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT

    builder.byteValue(value);

    return builder.build();
}


ByteResult ByteOperationHandler::shiftRightLogical(Z80Byte data) {
    ByteResultBuilder builder;
    auto value = Z80Byte((data.getValue() >> 1) & ~0x80); // NOLINT

    builder.carryBit((data.getValue() & 0x01) == 0x01); // NOLINT

    builder.hasParity(hasEvenParity(value.getValue()));

    builder.signBit(signFromValue(data)); // NOLINT
    builder.isZero(value.getValue() == 0); // NOLINT
    builder.halfCarryBit(false);

    builder.byteValue(value);

    return builder.build();
}

ByteResult ByteOperationHandler::enableBit(int bit, Z80Byte data) {
    ByteResultBuilder builder;
    builder.byteValue(data.setBit(bit, true));

    return builder.build();
}

ByteResult ByteOperationHandler::clearBit(int bit, Z80Byte data) {
    ByteResultBuilder builder;
    builder.byteValue(data.setBit(bit, false));

    return builder.build();
}

ByteResult ByteOperationHandler::testBit(int bit, Z80Byte data) {
    ByteResultBuilder builder;

    if (data.isBitEnabled(bit)) {
        builder.isZero(false);
        builder.hasParity(false);
    } else {
        builder.isZero(true);
        builder.hasParity(true);
    }

    builder.halfCarryBit(true);

    return builder.build();
}

bool ByteOperationHandler::parityFromValue(Z80Byte data) {
    return hasEvenParity(data.getValue());
}

bool ByteOperationHandler::zeroFromValue(Z80Byte data) {
    return data.getValue() == 0;
}

bool ByteOperationHandler::signFromValue(Z80Byte data) {
    return data.isBitEnabled(7);
}
